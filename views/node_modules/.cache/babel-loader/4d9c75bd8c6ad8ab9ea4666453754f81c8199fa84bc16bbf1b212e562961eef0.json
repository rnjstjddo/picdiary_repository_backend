{"ast":null,"code":"/** 위도, 경도를 x,y 격자 포인트로 변경 */\nvar RE = 6371.00877; // 지구 반경(km)\nvar GRID = 5.0; // 격자 간격(km)\nvar SLAT1 = 30.0; // 투영 위도1(degree)\nvar SLAT2 = 60.0; // 투영 위도2(degree)\nvar OLON = 126.0; // 기준점 경도(degree)\nvar OLAT = 38.0; // 기준점 위도(degree)\nvar XO = 43; // 기준점 X좌표(GRID)\nvar YO = 136; // 기1준점 Y좌표(GRID)\n\n// LCC DFS 좌표변환 ( code : \"toXY\"(위경도->좌표, v1:위도, v2:경도), \"toLL\"(좌표->위경도,v1:x, v2:y) )\nexport const dfs_xy_conv = (code, v1, v2) => {\n  // LCC DFS 좌표변환을 위한 기초 자료\n  var DEGRAD = Math.PI / 180.0;\n  var RADDEG = 180.0 / Math.PI;\n  var re = RE / GRID;\n  var slat1 = SLAT1 * DEGRAD;\n  var slat2 = SLAT2 * DEGRAD;\n  var olon = OLON * DEGRAD;\n  var olat = OLAT * DEGRAD;\n  var sn = Math.tan(Math.PI * 0.25 + slat2 * 0.5) / Math.tan(Math.PI * 0.25 + slat1 * 0.5);\n  sn = Math.log(Math.cos(slat1) / Math.cos(slat2)) / Math.log(sn);\n  var sf = Math.tan(Math.PI * 0.25 + slat1 * 0.5);\n  sf = Math.pow(sf, sn) * Math.cos(slat1) / sn;\n  var ro = Math.tan(Math.PI * 0.25 + olat * 0.5);\n  ro = re * sf / Math.pow(ro, sn);\n  var rs = {};\n  if (code == \"toXY\") {\n    rs[\"lat\"] = v1;\n    rs[\"lng\"] = v2;\n    var ra = Math.tan(Math.PI * 0.25 + v1 * DEGRAD * 0.5);\n    ra = re * sf / Math.pow(ra, sn);\n    var theta = v2 * DEGRAD - olon;\n    if (theta > Math.PI) theta -= 2.0 * Math.PI;\n    if (theta < -Math.PI) theta += 2.0 * Math.PI;\n    theta *= sn;\n    rs[\"x\"] = Math.floor(ra * Math.sin(theta) + XO + 0.5);\n    rs[\"y\"] = Math.floor(ro - ra * Math.cos(theta) + YO + 0.5);\n  } else {\n    rs[\"x\"] = v1;\n    rs[\"y\"] = v2;\n    var xn = v1 - XO;\n    var yn = ro - v2 + YO;\n    ra = Math.sqrt(xn * xn + yn * yn);\n    if (sn < 0.0) return -ra;\n    var alat = Math.pow(re * sf / ra, 1.0 / sn);\n    alat = 2.0 * Math.atan(alat) - Math.PI * 0.5;\n    if (Math.abs(xn) <= 0.0) {\n      theta = 0.0;\n    } else {\n      if (Math.abs(yn) <= 0.0) {\n        theta = Math.PI * 0.5;\n        if (xn < 0.0) return -theta;\n      } else theta = Math.atan2(xn, yn);\n    }\n    var alon = theta / sn + olon;\n    rs[\"lat\"] = alat * RADDEG;\n    rs[\"lng\"] = alon * RADDEG;\n  }\n  return rs;\n};","map":{"version":3,"names":["RE","GRID","SLAT1","SLAT2","OLON","OLAT","XO","YO","dfs_xy_conv","code","v1","v2","DEGRAD","Math","PI","RADDEG","re","slat1","slat2","olon","olat","sn","tan","log","cos","sf","pow","ro","rs","ra","theta","floor","sin","xn","yn","sqrt","alat","atan","abs","atan2","alon"],"sources":["C:/Users/win10/Desktop/picdiary/views/src/utils/xy.js"],"sourcesContent":["/** 위도, 경도를 x,y 격자 포인트로 변경 */\r\nvar RE = 6371.00877; // 지구 반경(km)\r\nvar GRID = 5.0; // 격자 간격(km)\r\nvar SLAT1 = 30.0; // 투영 위도1(degree)\r\nvar SLAT2 = 60.0; // 투영 위도2(degree)\r\nvar OLON = 126.0; // 기준점 경도(degree)\r\nvar OLAT = 38.0; // 기준점 위도(degree)\r\nvar XO = 43; // 기준점 X좌표(GRID)\r\nvar YO = 136; // 기1준점 Y좌표(GRID)\r\n\r\n// LCC DFS 좌표변환 ( code : \"toXY\"(위경도->좌표, v1:위도, v2:경도), \"toLL\"(좌표->위경도,v1:x, v2:y) )\r\nexport const dfs_xy_conv = (code, v1, v2) => {\r\n  // LCC DFS 좌표변환을 위한 기초 자료\r\n  var DEGRAD = Math.PI / 180.0;\r\n  var RADDEG = 180.0 / Math.PI;\r\n\r\n  var re = RE / GRID;\r\n  var slat1 = SLAT1 * DEGRAD;\r\n  var slat2 = SLAT2 * DEGRAD;\r\n  var olon = OLON * DEGRAD;\r\n  var olat = OLAT * DEGRAD;\r\n\r\n  var sn =\r\n    Math.tan(Math.PI * 0.25 + slat2 * 0.5) /\r\n    Math.tan(Math.PI * 0.25 + slat1 * 0.5);\r\n  sn = Math.log(Math.cos(slat1) / Math.cos(slat2)) / Math.log(sn);\r\n  var sf = Math.tan(Math.PI * 0.25 + slat1 * 0.5);\r\n  sf = (Math.pow(sf, sn) * Math.cos(slat1)) / sn;\r\n  var ro = Math.tan(Math.PI * 0.25 + olat * 0.5);\r\n  ro = (re * sf) / Math.pow(ro, sn);\r\n  var rs = {};\r\n  if (code == \"toXY\") {\r\n    rs[\"lat\"] = v1;\r\n    rs[\"lng\"] = v2;\r\n    var ra = Math.tan(Math.PI * 0.25 + v1 * DEGRAD * 0.5);\r\n    ra = (re * sf) / Math.pow(ra, sn);\r\n    var theta = v2 * DEGRAD - olon;\r\n    if (theta > Math.PI) theta -= 2.0 * Math.PI;\r\n    if (theta < -Math.PI) theta += 2.0 * Math.PI;\r\n    theta *= sn;\r\n    rs[\"x\"] = Math.floor(ra * Math.sin(theta) + XO + 0.5);\r\n    rs[\"y\"] = Math.floor(ro - ra * Math.cos(theta) + YO + 0.5);\r\n  } else {\r\n    rs[\"x\"] = v1;\r\n    rs[\"y\"] = v2;\r\n    var xn = v1 - XO;\r\n    var yn = ro - v2 + YO;\r\n    ra = Math.sqrt(xn * xn + yn * yn);\r\n    if (sn < 0.0) return -ra;\r\n    var alat = Math.pow((re * sf) / ra, 1.0 / sn);\r\n    alat = 2.0 * Math.atan(alat) - Math.PI * 0.5;\r\n\r\n    if (Math.abs(xn) <= 0.0) {\r\n      theta = 0.0;\r\n    } else {\r\n      if (Math.abs(yn) <= 0.0) {\r\n        theta = Math.PI * 0.5;\r\n        if (xn < 0.0) return -theta;\r\n      } else theta = Math.atan2(xn, yn);\r\n    }\r\n    var alon = theta / sn + olon;\r\n    rs[\"lat\"] = alat * RADDEG;\r\n    rs[\"lng\"] = alon * RADDEG;\r\n  }\r\n  return rs;\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}